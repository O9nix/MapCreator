<!DOCTYPE html>
<html>
<head>
    <title>Прямые линии на канвасе</title>
    <style>
        canvas {
            border: 2px solid #0000; /* fixed typo */
            cursor: crosshair;
        }
        .controls {
            margin: 10px 0;
        }
        button {
            margin-right: 10px;
            padding: 5px 10px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button onclick="clearCanvas()">Очистить</button>
        <label>Цвет: <input type="color" id="colorPicker" value="#000000"></label>
        <label>Путь: <input type="checkbox" id="path"></label>
        <label>Толщина: <input type="range" id="lineWidth" min="1" max="20" value="2"></label>
    </div>
    <canvas id="drawingCanvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        const lineWidth = document.getElementById('lineWidth');
        const pathCheckbox = document.getElementById('path');

        const NODE_RADIUS = 6;
        const SNAP_TOLERANCE = 10; // pixels

        let isDrawing = false;
        let startX = 0, startY = 0;
        let currentX = 0, currentY = 0;
        let lines = [];
        let nodes = []; // store unique nodes: {x, y, color}

        // Helper: find node near (x, y)
        function findNodeNear(x, y) {
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                const dx = x - node.x;
                const dy = y - node.y;
                if (Math.sqrt(dx * dx + dy * dy) <= SNAP_TOLERANCE) {
                    return { index: i, x: node.x, y: node.y };
                }
            }
            return null;
        }

        // Add node only if not near existing one
        function addNode(x, y, color) {
            const existing = findNodeNear(x, y);
            if (existing) {
                return existing; // reuse existing
            }
            const newNode = { x, y, color };
            nodes.push(newNode);
            return { index: nodes.length - 1, x, y };
        }

        canvas.addEventListener('mousedown', (e) => {
            const x = e.offsetX;
            const y = e.offsetY;

            let snap = findNodeNear(x, y);
            if (snap) {
                startX = snap.x;
                startY = snap.y;
            } else if (pathCheckbox.checked && lines.length > 0) {
                // Path mode: start from last line's end
                const lastLine = lines[lines.length - 1];
                startX = lastLine.x2;
                startY = lastLine.y2;
            } else {
                // Normal mode or first line
                startX = x;
                startY = y;
                // Add start node only if not snapped
                if (!snap) addNode(startX, startY, colorPicker.value);
            }

            isDrawing = true;
        });

        canvas.addEventListener('mousemove', (e) => {
            currentX = e.offsetX;
            currentY = e.offsetY;

            if (isDrawing) {
                redraw();
                // Draw preview line
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(currentX, currentY);
                ctx.strokeStyle = colorPicker.value;
                ctx.lineWidth = lineWidth.value;
                ctx.setLineDash([5, 5]);
                ctx.stroke();

                // Preview endpoint circle
                ctx.beginPath();
                ctx.arc(currentX, currentY, NODE_RADIUS, 0, Math.PI * 2);
                ctx.setLineDash([5, 5]);
                ctx.stroke();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (!isDrawing) return;

            // Finalize line
            const endSnap = findNodeNear(currentX, currentY);
            let endX = endSnap ? endSnap.x : currentX;
            let endY = endSnap ? endSnap.y : currentY;

            // Save line
            lines.push({
                x1: startX,
                y1: startY,
                x2: endX,
                y2: endY,
                color: colorPicker.value,
                width: lineWidth.value
            });

            // Ensure both endpoints are in nodes
            addNode(startX, startY, colorPicker.value);
            addNode(endX, endY, colorPicker.value);

            isDrawing = false;
            redraw(); // Redraw without preview
        });

        canvas.addEventListener('mouseout', () => {
            if (isDrawing) {
                // Optionally cancel drawing on leave
                isDrawing = false;
            }
        });

        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw all lines
            lines.forEach(line => {
                ctx.beginPath();
                ctx.moveTo(line.x1, line.y1);
                ctx.lineTo(line.x2, line.y2);
                ctx.strokeStyle = line.color;
                ctx.lineWidth = line.width;
                ctx.lineCap = 'round';
                ctx.setLineDash([]);
                ctx.stroke();
            });

            // Draw all nodes
            nodes.forEach(node => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);
                ctx.strokeStyle = node.color;
                ctx.stroke();
            });
        }

        function clearCanvas() {
            lines = [];
            nodes = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    </script>
</body>
</html>